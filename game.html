<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Battleship 3D - Play Against AI</title>
    <link rel="stylesheet" href="css/style.css" />
    <style>
      /* Ensure the entire viewport is used for the canvas */
      body {
        margin: 0;
        overflow: hidden;
      }
      /* Overlay for game state info */
      #overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px;
        color: #fff;
        font-family: sans-serif;
        border-radius: 4px;
      }
      #overlay p {
        margin: 5px 0;
      }
      #restartGame {
        margin-top: 10px;
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- Overlay displays turn indicator, wins count, messages and a restart button -->
    <div id="overlay">
      <p id="turnIndicator">Turn: Player</p>
      <p id="wins">Wins: 0</p>
      <p id="message"></p>
      <button id="restartGame" style="display: none;">Restart Game</button>
    </div>

    <!-- We'll use Three.js (and optionally GSAP) for our 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script>

    <script>
      /* ----- GAME PARAMETERS ----- */
      const boardSize = 10; // 10 x 10 grid
      const cellSize = 1; // each cell is 1 unit
      const numShips = 5; // number of ship cells per board

      let currentTurn = "player"; // "player" or "ai"
      let playerShipRemaining = numShips;
      let aiShipRemaining = numShips;

      let playerBoard = []; // 2D array for player's board
      let aiBoard = []; // 2D array for AI board

      // We'll store the Three.js meshes (cells) in groups for each board.
      let playerGroup, aiGroup;
      let scene, camera, renderer, raycaster;

      // Scoreboard (persistent wins count from localStorage)
      let winsCount = localStorage.getItem("wins")
        ? parseInt(localStorage.getItem("wins"))
        : 0;

      /* ----- UTILITY FUNCTIONS ----- */
      function updateOverlay() {
        document.getElementById("turnIndicator").innerText =
          "Turn: " + (currentTurn === "player" ? "Player" : "AI");
        document.getElementById("wins").innerText = "Wins: " + winsCount;
      }

      function saveWins() {
        localStorage.setItem("wins", winsCount);
      }

      function showMessage(text) {
        document.getElementById("message").innerText = text;
      }

      function endGame(victory) {
        // Disable further clicks by setting turn to null.
        currentTurn = null;
        if (victory) {
          winsCount++;
          saveWins();
          showMessage("Victory! You have beaten the AI.");
        } else {
          showMessage("Defeat! AI has beaten you.");
        }
        document.getElementById("restartGame").style.display = "inline-block";
      }

      function restartGame() {
        // Simply reload the page
        window.location.reload();
      }

      /* ----- INITIALIZE BOARDS ----- */
      function initBoard(boardArray) {
        // Create a 2D boardSize x boardSize array.
        for (let i = 0; i < boardSize; i++) {
          boardArray[i] = [];
          for (let j = 0; j < boardSize; j++) {
            boardArray[i][j] = {
              ship: false,
              hit: false,
              mesh: null,
              row: i,
              col: j,
            };
          }
        }
      }

      function placeShipsRandomly(boardArray) {
        let placed = 0;
        while (placed < numShips) {
          const i = Math.floor(Math.random() * boardSize);
          const j = Math.floor(Math.random() * boardSize);
          if (!boardArray[i][j].ship) {
            boardArray[i][j].ship = true;
            placed++;
          }
        }
      }

      /* ----- THREE.JS INITIALIZATION ----- */
      function initScene() {
        console.log("Initializing scene...");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e90ff); // blue background

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();

        // Create two groups: one for the player's board and one for the AI board.
        playerGroup = new THREE.Group();
        aiGroup = new THREE.Group();
        // Offset the groups so that they're side by side.
        playerGroup.position.x = -7;
        aiGroup.position.x = 7;
        scene.add(playerGroup);
        scene.add(aiGroup);

        // Add ambient light.
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      /* ----- CREATE THE BOARDS ----- */
      function createBoardVisuals(boardArray, group, boardType) {
        // The boardType is either "player" or "ai"
        const geometry = new THREE.PlaneGeometry(cellSize * 0.9, cellSize * 0.9);
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            // Choose initial color:
            // For AI board, default grey.
            // For player's board, if there is a ship, show green; if not, light grey.
            let color;
            if (boardType === "player") {
              color = boardArray[i][j].ship ? 0x00aa00 : 0xdddddd;
            } else {
              color = 0xdddddd;
            }
            const material = new THREE.MeshBasicMaterial({
              color: color,
              side: THREE.DoubleSide,
            });
            const cell = new THREE.Mesh(geometry, material);
            cell.rotation.x = -Math.PI / 2;
            // Center board around origin: shift by boardSize/2.
            cell.position.x = i - boardSize / 2 + cellSize / 2;
            cell.position.z = j - boardSize / 2 + cellSize / 2;
            // Store extra info in userData.
            cell.userData = {
              row: i,
              col: j,
              board: boardType, // "player" or "ai"
            };
            boardArray[i][j].mesh = cell;
            group.add(cell);
          }
        }
      }

      /* ----- GAME LOGIC ----- */
      // Process a player click on the AI board.
      function onPlayerClick(event) {
        // Only process if it's player's turn.
        if (currentTurn !== "player") return;

        // Calculate mouse position in normalized device coordinates.
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        // Only check intersections with AI board cells.
        const intersects = raycaster.intersectObjects(aiGroup.children);
        if (intersects.length > 0) {
          const cell = intersects[0].object;
          const row = cell.userData.row;
          const col = cell.userData.col;
          const cellData = aiBoard[row][col];
          // If already hit, ignore.
          if (cellData.hit) return;

          cellData.hit = true;
          if (cellData.ship) {
            // Hit ship: mark red.
            cell.material.color.set(0xff0000);
            aiShipRemaining--;
            // Animate explosion (using GSAP) for effect.
            gsap.to(cell.scale, {
              x: 1.5,
              y: 1.5,
              z: 1.5,
              duration: 0.3,
              yoyo: true,
              repeat: 1,
            });
          } else {
            // Miss: mark blue.
            cell.material.color.set(0x0000ff);
          }
          // Check for win.
          if (aiShipRemaining <= 0) {
            updateOverlay();
            endGame(true);
          } else {
            // Switch turn to AI.
            currentTurn = "ai";
            updateOverlay();
            setTimeout(aiTurn, 1000);
          }
        }
      }

      // AI randomly selects a cell on the player's board.
      function aiTurn() {
