<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Battleship 3D - Play Against AI</title>
    <link rel="stylesheet" href="css/style.css" />
    <style>
      /* Make sure the viewport is fully used */
      body {
        margin: 0;
        overflow: hidden;
      }
      /* Overlay to display game info */
      #overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px;
        color: #fff;
        font-family: sans-serif;
        border-radius: 4px;
      }
      #overlay p {
        margin: 5px 0;
      }
      #restartGame {
        margin-top: 10px;
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- Overlay displays turn indicator, wins count, and messages -->
    <div id="overlay">
      <p id="turnIndicator">Turn: Player</p>
      <p id="wins">Wins: 0</p>
      <p id="message"></p>
      <button id="restartGame" style="display: none;">Restart Game</button>
    </div>

    <!-- Three.js and GSAP libraries from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script>

    <script>
      // ----- GAME PARAMETERS -----
      const boardSize = 10; // 10x10 grids
      const cellSize = 1;
      const numShips = 5; // number of ship cells per board

      let currentTurn = "player"; // "player" or "ai"
      let playerShipRemaining = numShips;
      let aiShipRemaining = numShips;

      let playerBoard = []; // 2D arrays for boards
      let aiBoard = [];

      // Three.js groups for each board, and other scene variables.
      let playerGroup, aiGroup;
      let scene, camera, renderer, raycaster;

      // Scoreboard using localStorage.
      let winsCount = localStorage.getItem("wins")
        ? parseInt(localStorage.getItem("wins"))
        : 0;

      // ----- UTILITY FUNCTIONS -----
      function updateOverlay() {
        document.getElementById("turnIndicator").innerText =
          "Turn: " + (currentTurn === "player" ? "Player" : "AI");
        document.getElementById("wins").innerText = "Wins: " + winsCount;
      }

      function saveWins() {
        localStorage.setItem("wins", winsCount);
      }

      function showMessage(text) {
        document.getElementById("message").innerText = text;
      }

      function endGame(victory) {
        // Lock out further clicks
        currentTurn = null;
        if (victory) {
          winsCount++;
          saveWins();
          showMessage("Victory! You beat the AI.");
        } else {
          showMessage("Defeat! The AI wins.");
        }
        document.getElementById("restartGame").style.display = "inline-block";
      }

      function restartGame() {
        window.location.reload();
      }

      // ----- BOARD INITIALIZATION -----
      function initBoard(boardArray) {
        for (let i = 0; i < boardSize; i++) {
          boardArray[i] = [];
          for (let j = 0; j < boardSize; j++) {
            boardArray[i][j] = {
              ship: false,
              hit: false,
              mesh: null,
              row: i,
              col: j,
            };
          }
        }
      }

      function placeShipsRandomly(boardArray) {
        let placed = 0;
        while (placed < numShips) {
          const i = Math.floor(Math.random() * boardSize);
          const j = Math.floor(Math.random() * boardSize);
          if (!boardArray[i][j].ship) {
            boardArray[i][j].ship = true;
            placed++;
          }
        }
      }

      // ----- THREE.JS INITIALIZATION -----
      function initScene() {
        console.log("Initializing scene...");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e90ff);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();

        // Two groups: player board shifted left, AI board shifted right.
        playerGroup = new THREE.Group();
        aiGroup = new THREE.Group();
        playerGroup.position.x = -7;
        aiGroup.position.x = 7;
        scene.add(playerGroup);
        scene.add(aiGroup);

        // Ambient light for visibility.
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ----- VISUAL BOARD CREATION -----
      function createBoardVisuals(boardArray, group, boardType) {
        // boardType is "player" or "ai"
        const geometry = new THREE.PlaneGeometry(cellSize * 0.9, cellSize * 0.9);
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            let color;
            // For player board: show ships in green.
            if (boardType === "player") {
              color = boardArray[i][j].ship ? 0x00aa00 : 0xdddddd;
            } else {
              // For AI board, ships remain hidden initially.
              color = 0xdddddd;
            }
            const material = new THREE.MeshBasicMaterial({
              color: color,
              side: THREE.DoubleSide,
            });
            const cell = new THREE.Mesh(geometry, material);
            cell.rotation.x = -Math.PI / 2;
            cell.position.x = i - boardSize / 2 + cellSize / 2;
            cell.position.z = j - boardSize / 2 + cellSize / 2;
            cell.userData = { row: i, col: j, board: boardType };
            boardArray[i][j].mesh = cell;
            group.add(cell);
          }
        }
      }

      // ----- GAME LOGIC -----
      function onPlayerClick(event) {
        if (currentTurn !== "player") return;

        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(aiGroup.children);
        if (intersects.length > 0) {
          const cell = intersects[0].object;
          const row = cell.userData.row;
          const col = cell.userData.col;
          const cellData = aiBoard[row][col];
          if (cellData.hit) return;
          cellData.hit = true;
          if (cellData.ship) {
            cell.material.color.set(0xff0000);
            aiShipRemaining--;
            gsap.to(cell.scale, {
              x: 1.5,
              y: 1.5,
              z: 1.5,
              duration: 0.3,
              yoyo: true,
              repeat: 1,
            });
          } else {
            cell.material.color.set(0x0000ff);
          }
          if (aiShipRemaining <= 0) {
            updateOverlay();
            endGame(true);
          } else {
            currentTurn = "ai";
            updateOverlay();
            setTimeout(aiTurn, 1000);
          }
        }
      }

      function aiTurn() {
        let available = [];
        for (let i = 0; i < boardSize; i++) {
          for (let j = 0; j < boardSize; j++) {
            if (!playerBoard[i][j].hit) {
              available.push({ i, j });
            }
          }
        }
        if (available.length === 0) return;
        const choice = available[Math.floor(Math.random() * available.length)];
        const cellData = playerBoard[choice.i][choice.j];
        cellData.hit = true;
        const cell = cellData.mesh;
        if (cellData.ship) {
          cell.material.color.set(0xff0000);
          playerShipRemaining--;
          gsap.to(cell.scale, {
            x: 1.5,
            y: 1.5,
            z: 1.5,
            duration: 0.3,
            yoyo: true,
            repeat: 1,
          });
        } else {
          cell.material.color.set(0x0000ff);
        }
        if (playerShipRemaining <= 0) {
          updateOverlay();
          endGame(false);
        } else {
          currentTurn = "player";
          updateOverlay();
        }
      }

      // ----- MAIN LOOP -----
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // ----- INITIALIZATION -----
      function initGame() {
        initBoard(playerBoard);
        initBoard(aiBoard);
        placeShipsRandomly(playerBoard);
        placeShipsRandomly(aiBoard);

        initScene();
        createBoardVisuals(playerBoard, playerGroup, "player");
        createBoardVisuals(aiBoard, aiGroup, "ai");

        updateOverlay();

        window.addEventListener("click", onPlayerClick, false);

        animate();
      }

      document.getElementById("restartGame").addEventListener("click", () => {
        restartGame();
      });

      initGame();
      console.log("Game initialized. Current turn: " + currentTurn);
    </script>
  </body>
</html>
